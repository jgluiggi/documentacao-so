<!doctype html><html lang=en-us><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="Diário do Dev: Deixando dinâmico"><title>Diário do Dev: Deixando dinâmico | Documentação do Projeto de SO</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.43056c0208714d72a9b07a03fd289886f46955ec4674e0455a120d0d7fd3b4aa.css media=all></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=https://jgluiggi.github.io/documentacao-so/tags/><u>T</u>ags</a></li></ul></nav><div id=single-header><h1>Diário do Dev: Deixando dinâmico</h1><div id=single-meta><span class=datesub>May 5, 2024</span>
<span id=tags>&nbsp;&nbsp;
<span><a href=http://localhost:1313/tags/dev/>#dev</a>
</span>&nbsp;</span></div></div><main><p>Hoje demos continuidade ao projeto, tornando as solicitações mais dinâmicas e adicionando uma configuração padrão
de HDD para rodar as simulações.</p><p>Como tornamos as solicitações mais dinâmicas? Simplesmente com um append a cada vez que processamos uma solicitação,
ainda não é tão dinâmico quanto um caso real (solicitações de tamanhos diferentes em tempos diferentes) mas é um começo.</p><p>A configuração padrão do HDD é a que estávamos usando antes, só que desacoplada:</p><table><thead><tr><th><strong>Configurações</strong></th><th style=text-align:right><strong>HDD</strong></th></tr></thead><tbody><tr><td>Tamanho do setor</td><td style=text-align:right>512B</td></tr><tr><td>Número de trilhas</td><td style=text-align:right>100</td></tr><tr><td>Setores por trilha</td><td style=text-align:right>50</td></tr><tr><td>Tempo de Seek</td><td style=text-align:right>1</td></tr><tr><td>Tempo de Rotação</td><td style=text-align:right>0.01</td></tr><tr><td>Tempo de Transferência</td><td style=text-align:right>0.1</td></tr></tbody></table><p>Adicionalmente, deixei os prints levemente mais organizados para facilitar a leitura:</p><p><p class=imgp><img loading=lazy src=/documentacao-so/print.png alt=Prints></p></p><h3 id=próximos-passos>Próximos passos:</h3><ul><li>Deixar o sistema mais dinâmico (distribuição normal com desvio padrão do NumPy veio em mente <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>)</li><li>Adicionar uma maneira de monitorar starvation de cada requisição (o cálculo atual é um mock terrível.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>)</li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Utilizaríamos para variar o tamanho dos grupos de requisições feitas, pra não só ocorrerem requisições de um acesso por vez.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Basicamente o valor de starvation para cada entrada é a maior starvation possível para aquele momento específico.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></main><br><footer><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,300))}setTimeout(scrollHandler,100)</script><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const s=e.querySelectorAll(".cl");let n="";s.forEach(e=>{n+=e.innerText}),navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script>window.store={"http://localhost:1313/":{title:"",tags:[],content:"",url:"http://localhost:1313/"},"http://localhost:1313/tags/dev/":{title:"Dev",tags:[],content:"",url:"http://localhost:1313/tags/dev/"},"http://localhost:1313/post/05-05-24/":{title:"Diário do Dev: Deixando dinâmico",tags:["dev"],content:`Hoje demos continuidade ao projeto, tornando as solicitações mais dinâmicas e adicionando uma configuração padrão de HDD para rodar as simulações.
Como tornamos as solicitações mais dinâmicas? Simplesmente com um append a cada vez que processamos uma solicitação, ainda não é tão dinâmico quanto um caso real (solicitações de tamanhos diferentes em tempos diferentes) mas é um começo.
A configuração padrão do HDD é a que estávamos usando antes, só que desacoplada:
Configurações HDD Tamanho do setor 512B Número de trilhas 100 Setores por trilha 50 Tempo de Seek 1 Tempo de Rotação 0.01 Tempo de Transferência 0.1 Adicionalmente, deixei os prints levemente mais organizados para facilitar a leitura:
Próximos passos: Deixar o sistema mais dinâmico (distribuição normal com desvio padrão do NumPy veio em mente 1) Adicionar uma maneira de monitorar starvation de cada requisição (o cálculo atual é um mock terrível.2) Utilizaríamos para variar o tamanho dos grupos de requisições feitas, pra não só ocorrerem requisições de um acesso por vez.&#160;&#x21a9;&#xfe0e;
Basicamente o valor de starvation para cada entrada é a maior starvation possível para aquele momento específico.&#160;&#x21a9;&#xfe0e;
`,url:"http://localhost:1313/post/05-05-24/"},"http://localhost:1313/post/":{title:"Posts",tags:[],content:"",url:"http://localhost:1313/post/"},"http://localhost:1313/tags/":{title:"Tags",tags:[],content:"",url:"http://localhost:1313/tags/"},"http://localhost:1313/post/03-05-24/":{title:"Diário do Dev: Nascimento",tags:["dev"],content:`Hoje, fizemos a implementação básica do nosso simulador de disco, que deverá indicar a latência de acesso para uma lista de blocos passados como entrada.
Conseguimos fazer uma base boa para o projeto usando a documentação da questão e nossa experiência com calcular esses acessos na mão em sala de aula; nosso primeiro algoritmo (não começamos com SSTF, acredite ou não) somente lia a lista que providenciamos em ordem, atualizando sua posição em cada acesso e calculando a latência através da soma do seek, da rotação e do tempo de transferência (ainda não fazemos operações de write, então o tempo de transferência atualmente não faz nada).
Depois desse proto-algoritmo, tentamos implementar o SSTF calculando o delta:
delta = abs(trilha - disco.trilha_atual) visto que nosso algoritmo apenas otimiza pelo tempo de seek (Shortest Seek Time First), essa é a base do nosso loop para calcular o tempo de latência.
Estamos randomizando a lista de blocos que iremos acessar usando o random, o que será bom se conseguirmos tirar gráficos desses experimentos (seria legal) para tentar fazer algumas comparações/conclusões interessantes.
Um efeito engraçado proveniente do jeito que implementamos nosso código: não há starvation. Isso acontece porque estamos rodando o algoritmo apenas com listas estáticas, ou seja, não existem requisições novas sendo feitas então não estamos empurrando as leituras de blocos distantes pro fim de toda a leitura, apenas lendo subgrupos de blocos sequencialmente.
Pra amanhã ficarão duas issues:
Uma de adicionar um HDD padrão como parâmetro; Outra de passarmos todas as infos de configuração do HDD como entrada. `,url:"http://localhost:1313/post/03-05-24/"},"http://localhost:1313/categories/":{title:"Categories",tags:[],content:"",url:"http://localhost:1313/categories/"}}</script><script defer src=/js/lunr.js></script><script defer src=/js/search.js></script></footer></body></html>