[{"categories":[],"contents":"Eu não ia fazer mais nada hoje mas acabei entrando de cabeça no problema de plotagem de gráficos e como mapear as solicitações para que seja fácil fazer os gráficos da forma correta.\nComo de costume, encontrei um probleminha chato:\nSolicitações têm latências individuais; Não encapsulamos solicitação; Preciso somar latência a cada solicitação toda vez que uma solicitação é concluída. Já que estou mexendo com lista e não uma tabela de solicitações com ID, sua tupla trilha-setor e sua latência, acabo me lascando pra mexer nisso do jeito que eu envisiono ser o certo.\nComecei refatorando a lista de tuplas para um Dicionário de tupla-latência, mas quando haviam solicitações à mesma trilha-setor, começamos a adicionar tempo de latência que não é daquela solicitação.\nAssim, quando aumentamos o número de solicitações, as consultas rápidas que costumávamos ter desaparecem completamente!\nPra sanar esse problema, acho que simplesmente criando uma classe solicitação com Id, solicitação e latência resolva, ou talvez minha cabeça ainda está pensando no projeto de psoft e essa solução vai ser ruim.\n","date":"2024-05-05","permalink":"http://localhost:1313/post/extra-05-05/","section":"","summary":"","tags":["",""],"title":"Extras do dia: Deixando dinâmico"},{"categories":[],"contents":"Hoje demos continuidade ao projeto, tornando as solicitações mais dinâmicas e adicionando uma configuração padrão de HDD para rodar as simulações.\nComo tornamos as solicitações mais dinâmicas? Simplesmente com um append a cada vez que processamos uma solicitação, ainda não é tão dinâmico quanto um caso real (solicitações de tamanhos diferentes em tempos diferentes) mas é um começo.\nA configuração padrão do HDD é a que estávamos usando antes, só que desacoplada:\nConfigurações HDD Tamanho do setor 512B Número de trilhas 100 Setores por trilha 50 Tempo de Seek 1 Tempo de Rotação 0.01 Tempo de Transferência 0.1 Adicionalmente, deixei os prints levemente mais organizados para facilitar a leitura:\nPróximos passos: Deixar o sistema mais dinâmico (distribuição normal com desvio padrão do NumPy veio em mente 1) Adicionar uma maneira de monitorar starvation de cada requisição (o cálculo atual é um mock terrível.2) Utilizaríamos para variar o tamanho dos grupos de requisições feitas, pra não só ocorrerem requisições de um acesso por vez.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBasicamente o valor de starvation para cada entrada é a maior starvation possível para aquele momento específico.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-05-05","permalink":"http://localhost:1313/post/05-05-24/","section":"","summary":"","tags":[""],"title":"Diário do Dev: Deixando dinâmico"},{"categories":[],"contents":"Hoje, fizemos a implementação básica do nosso simulador de disco, que deverá indicar a latência de acesso para uma lista de blocos passados como entrada.\nConseguimos fazer uma base boa para o projeto usando a documentação da questão e nossa experiência com calcular esses acessos na mão em sala de aula; nosso primeiro algoritmo (não começamos com SSTF, acredite ou não) somente lia a lista que providenciamos em ordem, atualizando sua posição em cada acesso e calculando a latência através da soma do seek, da rotação e do tempo de transferência (ainda não fazemos operações de write, então o tempo de transferência atualmente não faz nada).\nDepois desse proto-algoritmo, tentamos implementar o SSTF calculando o delta:\ndelta = abs(trilha - disco.trilha_atual) visto que nosso algoritmo apenas otimiza pelo tempo de seek (Shortest Seek Time First), essa é a base do nosso loop para calcular o tempo de latência.\nEstamos randomizando a lista de blocos que iremos acessar usando o random, o que será bom se conseguirmos tirar gráficos desses experimentos (seria legal) para tentar fazer algumas comparações/conclusões interessantes.\nUm efeito engraçado proveniente do jeito que implementamos nosso código: não há starvation. Isso acontece porque estamos rodando o algoritmo apenas com listas estáticas, ou seja, não existem requisições novas sendo feitas então não estamos empurrando as leituras de blocos distantes pro fim de toda a leitura, apenas lendo subgrupos de blocos sequencialmente.\nPra amanhã ficarão duas issues:\nUma de adicionar um HDD padrão como parâmetro; Outra de passarmos todas as infos de configuração do HDD como entrada. ","date":"2024-05-03","permalink":"http://localhost:1313/post/03-05-24/","section":"","summary":"","tags":[""],"title":"Diário do Dev: Nascimento"}]