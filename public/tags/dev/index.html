<!doctype html><html lang=en-us><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="Dev"><link rel=alternate type=application/rss+xml href=http://localhost:1313/tags/dev/index.xml title="Documentação do Projeto de SO"><title>Dev | Documentação do Projeto de SO</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.43056c0208714d72a9b07a03fd289886f46955ec4674e0455a120d0d7fd3b4aa.css media=all></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=https://jgluiggi.github.io/documentacao-so/tags/><u>T</u>ags</a></li></ul></nav><h1>Dev</h1><ul class=post-list><li><div style="display:grid;grid-template-columns:7em auto"><span class=date>May 5, 2024</span>
<a href=/post/05-05-24/>Diário do Dev: Deixando dinâmico</a></div></li><li><div style="display:grid;grid-template-columns:7em auto"><span class=date>May 5, 2024</span>
<a href=/post/extra-05-05/>Extras do dia: Deixando dinâmico</a></div></li><li><div style="display:grid;grid-template-columns:7em auto"><span class=date>May 3, 2024</span>
<a href=/post/03-05-24/>Diário do Dev: Nascimento</a></div></li></ul><br><footer><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,300))}setTimeout(scrollHandler,100)</script><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const s=e.querySelectorAll(".cl");let n="";s.forEach(e=>{n+=e.innerText}),navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script>window.store={"http://localhost:1313/":{title:"",tags:[],content:"",url:"http://localhost:1313/"},"http://localhost:1313/tags/dev/":{title:"Dev",tags:[],content:"",url:"http://localhost:1313/tags/dev/"},"http://localhost:1313/post/05-05-24/":{title:"Diário do Dev: Deixando dinâmico",tags:["dev"],content:`Hoje demos continuidade ao projeto, tornando as solicitações mais dinâmicas e adicionando uma configuração padrão de HDD para rodar as simulações.
Como tornamos as solicitações mais dinâmicas? Simplesmente com um append a cada vez que processamos uma solicitação, ainda não é tão dinâmico quanto um caso real (solicitações de tamanhos diferentes em tempos diferentes) mas é um começo.
A configuração padrão do HDD é a que estávamos usando antes, só que desacoplada:
Configurações HDD Tamanho do setor 512B Número de trilhas 100 Setores por trilha 50 Tempo de Seek 1 Tempo de Rotação 0.01 Tempo de Transferência 0.1 Adicionalmente, deixei os prints levemente mais organizados para facilitar a leitura:
Próximos passos: Deixar o sistema mais dinâmico (distribuição normal com desvio padrão do NumPy veio em mente 1) Adicionar uma maneira de monitorar starvation de cada requisição (o cálculo atual é um mock terrível.2) Utilizaríamos para variar o tamanho dos grupos de requisições feitas, pra não só ocorrerem requisições de um acesso por vez.&#160;&#x21a9;&#xfe0e;
Basicamente o valor de starvation para cada entrada é a maior starvation possível para aquele momento específico.&#160;&#x21a9;&#xfe0e;
`,url:"http://localhost:1313/post/05-05-24/"},"http://localhost:1313/tags/extra/":{title:"Extra",tags:[],content:"",url:"http://localhost:1313/tags/extra/"},"http://localhost:1313/post/extra-05-05/":{title:"Extras do dia: Deixando dinâmico",tags:["dev","extra"],content:`Eu não ia fazer mais nada hoje mas acabei entrando de cabeça no problema de plotagem de gráficos e como mapear as solicitações para que seja fácil fazer os gráficos da forma correta.
Como de costume, encontrei um probleminha chato:
Solicitações têm latências individuais; Não encapsulamos solicitação; Preciso somar latência a cada solicitação toda vez que uma solicitação é concluída. Já que estou mexendo com lista e não uma tabela de solicitações com ID, sua tupla trilha-setor e sua latência, acabo me lascando pra mexer nisso do jeito que eu envisiono ser o certo.
Comecei refatorando a lista de tuplas para um Dicionário de tupla-latência, mas quando haviam solicitações à mesma trilha-setor, começamos a adicionar tempo de latência que não é daquela solicitação.
Assim, quando aumentamos o número de solicitações, as consultas rápidas que costumávamos ter desaparecem completamente!
Pra sanar esse problema, acho que simplesmente criando uma classe solicitação com Id, solicitação e latência resolva, ou talvez minha cabeça ainda está pensando no projeto de psoft e essa solução vai ser ruim.
`,url:"http://localhost:1313/post/extra-05-05/"},"http://localhost:1313/post/":{title:"Posts",tags:[],content:"",url:"http://localhost:1313/post/"},"http://localhost:1313/tags/":{title:"Tags",tags:[],content:"",url:"http://localhost:1313/tags/"},"http://localhost:1313/post/03-05-24/":{title:"Diário do Dev: Nascimento",tags:["dev"],content:`Hoje, fizemos a implementação básica do nosso simulador de disco, que deverá indicar a latência de acesso para uma lista de blocos passados como entrada.
Conseguimos fazer uma base boa para o projeto usando a documentação da questão e nossa experiência com calcular esses acessos na mão em sala de aula; nosso primeiro algoritmo (não começamos com SSTF, acredite ou não) somente lia a lista que providenciamos em ordem, atualizando sua posição em cada acesso e calculando a latência através da soma do seek, da rotação e do tempo de transferência (ainda não fazemos operações de write, então o tempo de transferência atualmente não faz nada).
Depois desse proto-algoritmo, tentamos implementar o SSTF calculando o delta:
delta = abs(trilha - disco.trilha_atual) visto que nosso algoritmo apenas otimiza pelo tempo de seek (Shortest Seek Time First), essa é a base do nosso loop para calcular o tempo de latência.
Estamos randomizando a lista de blocos que iremos acessar usando o random, o que será bom se conseguirmos tirar gráficos desses experimentos (seria legal) para tentar fazer algumas comparações/conclusões interessantes.
Um efeito engraçado proveniente do jeito que implementamos nosso código: não há starvation. Isso acontece porque estamos rodando o algoritmo apenas com listas estáticas, ou seja, não existem requisições novas sendo feitas então não estamos empurrando as leituras de blocos distantes pro fim de toda a leitura, apenas lendo subgrupos de blocos sequencialmente.
Pra amanhã ficarão duas issues:
Uma de adicionar um HDD padrão como parâmetro; Outra de passarmos todas as infos de configuração do HDD como entrada. `,url:"http://localhost:1313/post/03-05-24/"},"http://localhost:1313/categories/":{title:"Categories",tags:[],content:"",url:"http://localhost:1313/categories/"},"http://localhost:1313/tags/dev-extra/":{title:"Dev, Extra",tags:[],content:"",url:"http://localhost:1313/tags/dev-extra/"}}</script><script defer src=/js/lunr.js></script><script defer src=/js/search.js></script></footer></body></html>